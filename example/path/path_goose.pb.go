// Code generated by protoc-gen-goose. DO NOT EDIT.

package path

import (
	context "context"
	server "github.com/go-leo/goose/server"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
)

type BoolPathGooseService interface {
	BoolPath(ctx context.Context, request *BoolPathRequest) (*httpbody.HttpBody, error)
}

func AppendBoolPathGooseRoute(router *http.ServeMux, service BoolPathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := boolPathGooseHandler{
		service: service,
		decoder: boolPathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolPathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{bool}/{opt_bool}/{wrap_bool}", server.Chain(handler.BoolPath(), options.Middlewares()...))
	return router
}

type boolPathGooseHandler struct {
	service                 BoolPathGooseService
	decoder                 boolPathGooseRequestDecoder
	encoder                 boolPathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h boolPathGooseHandler) BoolPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.BoolPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.BoolPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.BoolPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type boolPathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathGooseRequestDecoder) BoolPath(ctx context.Context, r *http.Request) (*BoolPathRequest, error) {
	req := &BoolPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "bool", "opt_bool", "wrap_bool")
	var varErr error
	req.Bool, varErr = server.DecodeForm[bool](varErr, vars, "bool", server.GetBool)
	req.OptBool, varErr = server.DecodeForm[*bool](varErr, vars, "opt_bool", server.GetBoolPtr)
	req.WrapBool, varErr = server.DecodeForm[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", server.GetBoolValue)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type boolPathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder boolPathGooseResponseEncoder) BoolPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Int32PathGooseService interface {
	Int32Path(ctx context.Context, request *Int32PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt32PathGooseRoute(router *http.ServeMux, service Int32PathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int32PathGooseHandler{
		service: service,
		decoder: int32PathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32PathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}", server.Chain(handler.Int32Path(), options.Middlewares()...))
	return router
}

type int32PathGooseHandler struct {
	service                 Int32PathGooseService
	decoder                 int32PathGooseRequestDecoder
	encoder                 int32PathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h int32PathGooseHandler) Int32Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int32Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int32PathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathGooseRequestDecoder) Int32Path(ctx context.Context, r *http.Request) (*Int32PathRequest, error) {
	req := &Int32PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "int32", "sint32", "sfixed32", "opt_int32", "opt_sint32", "opt_sfixed32", "wrap_int32")
	var varErr error
	req.Int32, varErr = server.DecodeForm[int32](varErr, vars, "int32", server.GetInt32)
	req.Sint32, varErr = server.DecodeForm[int32](varErr, vars, "sint32", server.GetInt32)
	req.Sfixed32, varErr = server.DecodeForm[int32](varErr, vars, "sfixed32", server.GetInt32)
	req.OptInt32, varErr = server.DecodeForm[*int32](varErr, vars, "opt_int32", server.GetInt32Ptr)
	req.OptSint32, varErr = server.DecodeForm[*int32](varErr, vars, "opt_sint32", server.GetInt32Ptr)
	req.OptSfixed32, varErr = server.DecodeForm[*int32](varErr, vars, "opt_sfixed32", server.GetInt32Ptr)
	req.WrapInt32, varErr = server.DecodeForm[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", server.GetInt32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int32PathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder int32PathGooseResponseEncoder) Int32Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Int64PathGooseService interface {
	Int64Path(ctx context.Context, request *Int64PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt64PathGooseRoute(router *http.ServeMux, service Int64PathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int64PathGooseHandler{
		service: service,
		decoder: int64PathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64PathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}", server.Chain(handler.Int64Path(), options.Middlewares()...))
	return router
}

type int64PathGooseHandler struct {
	service                 Int64PathGooseService
	decoder                 int64PathGooseRequestDecoder
	encoder                 int64PathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h int64PathGooseHandler) Int64Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int64Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int64PathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathGooseRequestDecoder) Int64Path(ctx context.Context, r *http.Request) (*Int64PathRequest, error) {
	req := &Int64PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "int64", "sint64", "sfixed64", "opt_int64", "opt_sint64", "opt_sfixed64", "wrap_int64")
	var varErr error
	req.Int64, varErr = server.DecodeForm[int64](varErr, vars, "int64", server.GetInt64)
	req.Sint64, varErr = server.DecodeForm[int64](varErr, vars, "sint64", server.GetInt64)
	req.Sfixed64, varErr = server.DecodeForm[int64](varErr, vars, "sfixed64", server.GetInt64)
	req.OptInt64, varErr = server.DecodeForm[*int64](varErr, vars, "opt_int64", server.GetInt64Ptr)
	req.OptSint64, varErr = server.DecodeForm[*int64](varErr, vars, "opt_sint64", server.GetInt64Ptr)
	req.OptSfixed64, varErr = server.DecodeForm[*int64](varErr, vars, "opt_sfixed64", server.GetInt64Ptr)
	req.WrapInt64, varErr = server.DecodeForm[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", server.GetInt64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int64PathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder int64PathGooseResponseEncoder) Int64Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Uint32PathGooseService interface {
	Uint32Path(ctx context.Context, request *Uint32PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint32PathGooseRoute(router *http.ServeMux, service Uint32PathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint32PathGooseHandler{
		service: service,
		decoder: uint32PathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32PathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}", server.Chain(handler.Uint32Path(), options.Middlewares()...))
	return router
}

type uint32PathGooseHandler struct {
	service                 Uint32PathGooseService
	decoder                 uint32PathGooseRequestDecoder
	encoder                 uint32PathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h uint32PathGooseHandler) Uint32Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint32Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint32PathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathGooseRequestDecoder) Uint32Path(ctx context.Context, r *http.Request) (*Uint32PathRequest, error) {
	req := &Uint32PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "uint32", "fixed32", "opt_uint32", "opt_fixed32", "wrap_uint32")
	var varErr error
	req.Uint32, varErr = server.DecodeForm[uint32](varErr, vars, "uint32", server.GetUint32)
	req.Fixed32, varErr = server.DecodeForm[uint32](varErr, vars, "fixed32", server.GetUint32)
	req.OptUint32, varErr = server.DecodeForm[*uint32](varErr, vars, "opt_uint32", server.GetUint32Ptr)
	req.OptFixed32, varErr = server.DecodeForm[*uint32](varErr, vars, "opt_fixed32", server.GetUint32Ptr)
	req.WrapUint32, varErr = server.DecodeForm[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", server.GetUint32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint32PathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder uint32PathGooseResponseEncoder) Uint32Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Uint64PathGooseService interface {
	Uint64Path(ctx context.Context, request *Uint64PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint64PathGooseRoute(router *http.ServeMux, service Uint64PathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint64PathGooseHandler{
		service: service,
		decoder: uint64PathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64PathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}", server.Chain(handler.Uint64Path(), options.Middlewares()...))
	return router
}

type uint64PathGooseHandler struct {
	service                 Uint64PathGooseService
	decoder                 uint64PathGooseRequestDecoder
	encoder                 uint64PathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h uint64PathGooseHandler) Uint64Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint64Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint64PathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathGooseRequestDecoder) Uint64Path(ctx context.Context, r *http.Request) (*Uint64PathRequest, error) {
	req := &Uint64PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "uint64", "fixed64", "opt_uint64", "opt_fixed64", "wrap_uint64")
	var varErr error
	req.Uint64, varErr = server.DecodeForm[uint64](varErr, vars, "uint64", server.GetUint64)
	req.Fixed64, varErr = server.DecodeForm[uint64](varErr, vars, "fixed64", server.GetUint64)
	req.OptUint64, varErr = server.DecodeForm[*uint64](varErr, vars, "opt_uint64", server.GetUint64Ptr)
	req.OptFixed64, varErr = server.DecodeForm[*uint64](varErr, vars, "opt_fixed64", server.GetUint64Ptr)
	req.WrapUint64, varErr = server.DecodeForm[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", server.GetUint64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint64PathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder uint64PathGooseResponseEncoder) Uint64Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type FloatPathGooseService interface {
	FloatPath(ctx context.Context, request *FloatPathRequest) (*httpbody.HttpBody, error)
}

func AppendFloatPathGooseRoute(router *http.ServeMux, service FloatPathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := floatPathGooseHandler{
		service: service,
		decoder: floatPathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatPathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{float}/{opt_float}/{wrap_float}", server.Chain(handler.FloatPath(), options.Middlewares()...))
	return router
}

type floatPathGooseHandler struct {
	service                 FloatPathGooseService
	decoder                 floatPathGooseRequestDecoder
	encoder                 floatPathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h floatPathGooseHandler) FloatPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.FloatPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.FloatPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.FloatPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type floatPathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathGooseRequestDecoder) FloatPath(ctx context.Context, r *http.Request) (*FloatPathRequest, error) {
	req := &FloatPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "float", "opt_float", "wrap_float")
	var varErr error
	req.Float, varErr = server.DecodeForm[float32](varErr, vars, "float", server.GetFloat32)
	req.OptFloat, varErr = server.DecodeForm[*float32](varErr, vars, "opt_float", server.GetFloat32Ptr)
	req.WrapFloat, varErr = server.DecodeForm[*wrapperspb.FloatValue](varErr, vars, "wrap_float", server.GetFloat32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type floatPathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder floatPathGooseResponseEncoder) FloatPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type DoublePathGooseService interface {
	DoublePath(ctx context.Context, request *DoublePathRequest) (*httpbody.HttpBody, error)
}

func AppendDoublePathGooseRoute(router *http.ServeMux, service DoublePathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := doublePathGooseHandler{
		service: service,
		decoder: doublePathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doublePathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{double}/{opt_double}/{wrap_double}", server.Chain(handler.DoublePath(), options.Middlewares()...))
	return router
}

type doublePathGooseHandler struct {
	service                 DoublePathGooseService
	decoder                 doublePathGooseRequestDecoder
	encoder                 doublePathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h doublePathGooseHandler) DoublePath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.DoublePath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.DoublePath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.DoublePath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type doublePathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathGooseRequestDecoder) DoublePath(ctx context.Context, r *http.Request) (*DoublePathRequest, error) {
	req := &DoublePathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "double", "opt_double", "wrap_double")
	var varErr error
	req.Double, varErr = server.DecodeForm[float64](varErr, vars, "double", server.GetFloat64)
	req.OptDouble, varErr = server.DecodeForm[*float64](varErr, vars, "opt_double", server.GetFloat64Ptr)
	req.WrapDouble, varErr = server.DecodeForm[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", server.GetFloat64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type doublePathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder doublePathGooseResponseEncoder) DoublePath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type StringPathGooseService interface {
	StringPath(ctx context.Context, request *StringPathRequest) (*httpbody.HttpBody, error)
}

func AppendStringPathGooseRoute(router *http.ServeMux, service StringPathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := stringPathGooseHandler{
		service: service,
		decoder: stringPathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringPathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{string}/{opt_string}/{wrap_string}/{multi_string...}", server.Chain(handler.StringPath(), options.Middlewares()...))
	return router
}

type stringPathGooseHandler struct {
	service                 StringPathGooseService
	decoder                 stringPathGooseRequestDecoder
	encoder                 stringPathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h stringPathGooseHandler) StringPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StringPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.StringPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StringPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type stringPathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathGooseRequestDecoder) StringPath(ctx context.Context, r *http.Request) (*StringPathRequest, error) {
	req := &StringPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "string", "opt_string", "wrap_string", "multi_string")
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	req.MultiString = vars.Get("multi_string")
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type stringPathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder stringPathGooseResponseEncoder) StringPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type EnumPathGooseService interface {
	EnumPath(ctx context.Context, request *EnumPathRequest) (*httpbody.HttpBody, error)
}

func AppendEnumPathGooseRoute(router *http.ServeMux, service EnumPathGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := enumPathGooseHandler{
		service: service,
		decoder: enumPathGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumPathGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/{status}/{opt_status}", server.Chain(handler.EnumPath(), options.Middlewares()...))
	return router
}

type enumPathGooseHandler struct {
	service                 EnumPathGooseService
	decoder                 enumPathGooseRequestDecoder
	encoder                 enumPathGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h enumPathGooseHandler) EnumPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EnumPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EnumPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EnumPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type enumPathGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathGooseRequestDecoder) EnumPath(ctx context.Context, r *http.Request) (*EnumPathRequest, error) {
	req := &EnumPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := server.FormFromPath(r, "status", "opt_status")
	var varErr error
	req.Status, varErr = server.DecodeForm[EnumPathRequest_Status](varErr, vars, "status", server.GetInt[EnumPathRequest_Status])
	req.OptStatus, varErr = server.DecodeForm[*EnumPathRequest_Status](varErr, vars, "opt_status", server.GetIntPtr[EnumPathRequest_Status])
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type enumPathGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder enumPathGooseResponseEncoder) EnumPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}
