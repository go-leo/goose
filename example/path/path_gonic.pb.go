// Code generated by protoc-gen-gonic. DO NOT EDIT.

package path

import (
	context "context"
	gin "github.com/gin-gonic/gin"
	gonic "github.com/go-leo/gonic"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

type BoolPathGonicService interface {
	BoolPath(ctx context.Context, request *BoolPathRequest) (*httpbody.HttpBody, error)
}

func AppendBoolPathGonicRoute[Router gin.IRoutes](router Router, service BoolPathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := boolPathGonicHandler{
		service: service,
		decoder: boolPathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolPathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:bool/:opt_bool/:wrap_bool", gonic.Chain(handler.BoolPath(), options.Middlewares()...)...)
	return router
}

type boolPathGonicHandler struct {
	service                 BoolPathGonicService
	decoder                 boolPathGonicRequestDecoder
	encoder                 boolPathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h boolPathGonicHandler) BoolPath() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.BoolPath(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.BoolPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.BoolPath(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type boolPathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathGonicRequestDecoder) BoolPath(ctx *gin.Context) (*BoolPathRequest, error) {
	r := ctx.Request
	req := &BoolPathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Bool, varErr = gonic.DecodeForm[bool](varErr, vars, "bool", gonic.GetBool)
	req.OptBool, varErr = gonic.DecodeForm[*bool](varErr, vars, "opt_bool", gonic.GetBoolPtr)
	req.WrapBool, varErr = gonic.DecodeForm[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", gonic.GetBoolValue)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type boolPathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder boolPathGonicResponseEncoder) BoolPath(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Int32PathGonicService interface {
	Int32Path(ctx context.Context, request *Int32PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt32PathGonicRoute[Router gin.IRoutes](router Router, service Int32PathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := int32PathGonicHandler{
		service: service,
		decoder: int32PathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32PathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:int32/:sint32/:sfixed32/:opt_int32/:opt_sint32/:opt_sfixed32/:wrap_int32", gonic.Chain(handler.Int32Path(), options.Middlewares()...)...)
	return router
}

type int32PathGonicHandler struct {
	service                 Int32PathGonicService
	decoder                 int32PathGonicRequestDecoder
	encoder                 int32PathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h int32PathGonicHandler) Int32Path() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Int32Path(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Int32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Int32Path(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type int32PathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathGonicRequestDecoder) Int32Path(ctx *gin.Context) (*Int32PathRequest, error) {
	r := ctx.Request
	req := &Int32PathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Int32, varErr = gonic.DecodeForm[int32](varErr, vars, "int32", gonic.GetInt32)
	req.Sint32, varErr = gonic.DecodeForm[int32](varErr, vars, "sint32", gonic.GetInt32)
	req.Sfixed32, varErr = gonic.DecodeForm[int32](varErr, vars, "sfixed32", gonic.GetInt32)
	req.OptInt32, varErr = gonic.DecodeForm[*int32](varErr, vars, "opt_int32", gonic.GetInt32Ptr)
	req.OptSint32, varErr = gonic.DecodeForm[*int32](varErr, vars, "opt_sint32", gonic.GetInt32Ptr)
	req.OptSfixed32, varErr = gonic.DecodeForm[*int32](varErr, vars, "opt_sfixed32", gonic.GetInt32Ptr)
	req.WrapInt32, varErr = gonic.DecodeForm[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", gonic.GetInt32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int32PathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder int32PathGonicResponseEncoder) Int32Path(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Int64PathGonicService interface {
	Int64Path(ctx context.Context, request *Int64PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt64PathGonicRoute[Router gin.IRoutes](router Router, service Int64PathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := int64PathGonicHandler{
		service: service,
		decoder: int64PathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64PathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:int64/:sint64/:sfixed64/:opt_int64/:opt_sint64/:opt_sfixed64/:wrap_int64", gonic.Chain(handler.Int64Path(), options.Middlewares()...)...)
	return router
}

type int64PathGonicHandler struct {
	service                 Int64PathGonicService
	decoder                 int64PathGonicRequestDecoder
	encoder                 int64PathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h int64PathGonicHandler) Int64Path() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Int64Path(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Int64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Int64Path(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type int64PathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathGonicRequestDecoder) Int64Path(ctx *gin.Context) (*Int64PathRequest, error) {
	r := ctx.Request
	req := &Int64PathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Int64, varErr = gonic.DecodeForm[int64](varErr, vars, "int64", gonic.GetInt64)
	req.Sint64, varErr = gonic.DecodeForm[int64](varErr, vars, "sint64", gonic.GetInt64)
	req.Sfixed64, varErr = gonic.DecodeForm[int64](varErr, vars, "sfixed64", gonic.GetInt64)
	req.OptInt64, varErr = gonic.DecodeForm[*int64](varErr, vars, "opt_int64", gonic.GetInt64Ptr)
	req.OptSint64, varErr = gonic.DecodeForm[*int64](varErr, vars, "opt_sint64", gonic.GetInt64Ptr)
	req.OptSfixed64, varErr = gonic.DecodeForm[*int64](varErr, vars, "opt_sfixed64", gonic.GetInt64Ptr)
	req.WrapInt64, varErr = gonic.DecodeForm[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", gonic.GetInt64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int64PathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder int64PathGonicResponseEncoder) Int64Path(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Uint32PathGonicService interface {
	Uint32Path(ctx context.Context, request *Uint32PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint32PathGonicRoute[Router gin.IRoutes](router Router, service Uint32PathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := uint32PathGonicHandler{
		service: service,
		decoder: uint32PathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32PathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:uint32/:fixed32/:opt_uint32/:opt_fixed32/:wrap_uint32", gonic.Chain(handler.Uint32Path(), options.Middlewares()...)...)
	return router
}

type uint32PathGonicHandler struct {
	service                 Uint32PathGonicService
	decoder                 uint32PathGonicRequestDecoder
	encoder                 uint32PathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h uint32PathGonicHandler) Uint32Path() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Uint32Path(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Uint32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Uint32Path(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type uint32PathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathGonicRequestDecoder) Uint32Path(ctx *gin.Context) (*Uint32PathRequest, error) {
	r := ctx.Request
	req := &Uint32PathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Uint32, varErr = gonic.DecodeForm[uint32](varErr, vars, "uint32", gonic.GetUint32)
	req.Fixed32, varErr = gonic.DecodeForm[uint32](varErr, vars, "fixed32", gonic.GetUint32)
	req.OptUint32, varErr = gonic.DecodeForm[*uint32](varErr, vars, "opt_uint32", gonic.GetUint32Ptr)
	req.OptFixed32, varErr = gonic.DecodeForm[*uint32](varErr, vars, "opt_fixed32", gonic.GetUint32Ptr)
	req.WrapUint32, varErr = gonic.DecodeForm[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", gonic.GetUint32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint32PathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder uint32PathGonicResponseEncoder) Uint32Path(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Uint64PathGonicService interface {
	Uint64Path(ctx context.Context, request *Uint64PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint64PathGonicRoute[Router gin.IRoutes](router Router, service Uint64PathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := uint64PathGonicHandler{
		service: service,
		decoder: uint64PathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64PathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:uint64/:fixed64/:opt_uint64/:opt_fixed64/:wrap_uint64", gonic.Chain(handler.Uint64Path(), options.Middlewares()...)...)
	return router
}

type uint64PathGonicHandler struct {
	service                 Uint64PathGonicService
	decoder                 uint64PathGonicRequestDecoder
	encoder                 uint64PathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h uint64PathGonicHandler) Uint64Path() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Uint64Path(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Uint64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Uint64Path(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type uint64PathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathGonicRequestDecoder) Uint64Path(ctx *gin.Context) (*Uint64PathRequest, error) {
	r := ctx.Request
	req := &Uint64PathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Uint64, varErr = gonic.DecodeForm[uint64](varErr, vars, "uint64", gonic.GetUint64)
	req.Fixed64, varErr = gonic.DecodeForm[uint64](varErr, vars, "fixed64", gonic.GetUint64)
	req.OptUint64, varErr = gonic.DecodeForm[*uint64](varErr, vars, "opt_uint64", gonic.GetUint64Ptr)
	req.OptFixed64, varErr = gonic.DecodeForm[*uint64](varErr, vars, "opt_fixed64", gonic.GetUint64Ptr)
	req.WrapUint64, varErr = gonic.DecodeForm[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", gonic.GetUint64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint64PathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder uint64PathGonicResponseEncoder) Uint64Path(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type FloatPathGonicService interface {
	FloatPath(ctx context.Context, request *FloatPathRequest) (*httpbody.HttpBody, error)
}

func AppendFloatPathGonicRoute[Router gin.IRoutes](router Router, service FloatPathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := floatPathGonicHandler{
		service: service,
		decoder: floatPathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatPathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:float/:opt_float/:wrap_float", gonic.Chain(handler.FloatPath(), options.Middlewares()...)...)
	return router
}

type floatPathGonicHandler struct {
	service                 FloatPathGonicService
	decoder                 floatPathGonicRequestDecoder
	encoder                 floatPathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h floatPathGonicHandler) FloatPath() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.FloatPath(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.FloatPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.FloatPath(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type floatPathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathGonicRequestDecoder) FloatPath(ctx *gin.Context) (*FloatPathRequest, error) {
	r := ctx.Request
	req := &FloatPathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Float, varErr = gonic.DecodeForm[float32](varErr, vars, "float", gonic.GetFloat32)
	req.OptFloat, varErr = gonic.DecodeForm[*float32](varErr, vars, "opt_float", gonic.GetFloat32Ptr)
	req.WrapFloat, varErr = gonic.DecodeForm[*wrapperspb.FloatValue](varErr, vars, "wrap_float", gonic.GetFloat32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type floatPathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder floatPathGonicResponseEncoder) FloatPath(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type DoublePathGonicService interface {
	DoublePath(ctx context.Context, request *DoublePathRequest) (*httpbody.HttpBody, error)
}

func AppendDoublePathGonicRoute[Router gin.IRoutes](router Router, service DoublePathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := doublePathGonicHandler{
		service: service,
		decoder: doublePathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doublePathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:double/:opt_double/:wrap_double", gonic.Chain(handler.DoublePath(), options.Middlewares()...)...)
	return router
}

type doublePathGonicHandler struct {
	service                 DoublePathGonicService
	decoder                 doublePathGonicRequestDecoder
	encoder                 doublePathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h doublePathGonicHandler) DoublePath() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.DoublePath(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.DoublePath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.DoublePath(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type doublePathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathGonicRequestDecoder) DoublePath(ctx *gin.Context) (*DoublePathRequest, error) {
	r := ctx.Request
	req := &DoublePathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Double, varErr = gonic.DecodeForm[float64](varErr, vars, "double", gonic.GetFloat64)
	req.OptDouble, varErr = gonic.DecodeForm[*float64](varErr, vars, "opt_double", gonic.GetFloat64Ptr)
	req.WrapDouble, varErr = gonic.DecodeForm[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", gonic.GetFloat64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type doublePathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder doublePathGonicResponseEncoder) DoublePath(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type StringPathGonicService interface {
	StringPath(ctx context.Context, request *StringPathRequest) (*httpbody.HttpBody, error)
}

func AppendStringPathGonicRoute[Router gin.IRoutes](router Router, service StringPathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := stringPathGonicHandler{
		service: service,
		decoder: stringPathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringPathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:string/:opt_string/:wrap_string/*catch_all", gonic.Chain(handler.StringPath(), options.Middlewares()...)...)
	return router
}

type stringPathGonicHandler struct {
	service                 StringPathGonicService
	decoder                 stringPathGonicRequestDecoder
	encoder                 stringPathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h stringPathGonicHandler) StringPath() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.StringPath(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.StringPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.StringPath(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type stringPathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathGonicRequestDecoder) StringPath(ctx *gin.Context) (*StringPathRequest, error) {
	r := ctx.Request
	req := &StringPathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	req.CatchAll = vars.Get("catch_all")
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type stringPathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder stringPathGonicResponseEncoder) StringPath(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type EnumPathGonicService interface {
	EnumPath(ctx context.Context, request *EnumPathRequest) (*httpbody.HttpBody, error)
}

func AppendEnumPathGonicRoute[Router gin.IRoutes](router Router, service EnumPathGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := enumPathGonicHandler{
		service: service,
		decoder: enumPathGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumPathGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/:status/:opt_status", gonic.Chain(handler.EnumPath(), options.Middlewares()...)...)
	return router
}

type enumPathGonicHandler struct {
	service                 EnumPathGonicService
	decoder                 enumPathGonicRequestDecoder
	encoder                 enumPathGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h enumPathGonicHandler) EnumPath() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.EnumPath(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.EnumPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.EnumPath(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type enumPathGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathGonicRequestDecoder) EnumPath(ctx *gin.Context) (*EnumPathRequest, error) {
	r := ctx.Request
	req := &EnumPathRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gonic.FormFromParams(ctx.Params)
	var varErr error
	req.Status, varErr = gonic.DecodeForm[EnumPathRequest_Status](varErr, vars, "status", gonic.GetInt[EnumPathRequest_Status])
	req.OptStatus, varErr = gonic.DecodeForm[*EnumPathRequest_Status](varErr, vars, "opt_status", gonic.GetIntPtr[EnumPathRequest_Status])
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type enumPathGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder enumPathGonicResponseEncoder) EnumPath(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}
