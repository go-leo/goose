// Code generated by protoc-gen-goose. DO NOT EDIT.

package query

import (
	context "context"
	server "github.com/go-leo/goose/server"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
)

type BoolQueryGooseService interface {
	BoolQuery(ctx context.Context, request *BoolQueryRequest) (*httpbody.HttpBody, error)
}

func AppendBoolQueryGooseRoute(router *http.ServeMux, service BoolQueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := boolQueryGooseHandler{
		service: service,
		decoder: boolQueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolQueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/bool", server.Chain(handler.BoolQuery(), options.Middlewares()...))
	return router
}

type boolQueryGooseHandler struct {
	service                 BoolQueryGooseService
	decoder                 boolQueryGooseRequestDecoder
	encoder                 boolQueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h boolQueryGooseHandler) BoolQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.BoolQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.BoolQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.BoolQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type boolQueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryGooseRequestDecoder) BoolQuery(ctx context.Context, r *http.Request) (*BoolQueryRequest, error) {
	req := &BoolQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = server.DecodeForm[bool](queryErr, queries, "bool", server.GetBool)
	req.OptBool, queryErr = server.DecodeForm[*bool](queryErr, queries, "opt_bool", server.GetBoolPtr)
	req.WrapBool, queryErr = server.DecodeForm[*wrapperspb.BoolValue](queryErr, queries, "wrap_bool", server.GetBoolValue)
	req.ListBool, queryErr = server.DecodeForm[[]bool](queryErr, queries, "list_bool", server.GetBoolSlice)
	req.ListWrapBool, queryErr = server.DecodeForm[[]*wrapperspb.BoolValue](queryErr, queries, "list_wrap_bool", server.GetBoolValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type boolQueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder boolQueryGooseResponseEncoder) BoolQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Int32QueryGooseService interface {
	Int32Query(ctx context.Context, request *Int32QueryRequest) (*httpbody.HttpBody, error)
}

func AppendInt32QueryGooseRoute(router *http.ServeMux, service Int32QueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int32QueryGooseHandler{
		service: service,
		decoder: int32QueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32QueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/int32", server.Chain(handler.Int32Query(), options.Middlewares()...))
	return router
}

type int32QueryGooseHandler struct {
	service                 Int32QueryGooseService
	decoder                 int32QueryGooseRequestDecoder
	encoder                 int32QueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h int32QueryGooseHandler) Int32Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int32Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int32QueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryGooseRequestDecoder) Int32Query(ctx context.Context, r *http.Request) (*Int32QueryRequest, error) {
	req := &Int32QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Int32, queryErr = server.DecodeForm[int32](queryErr, queries, "int32", server.GetInt32)
	req.Sint32, queryErr = server.DecodeForm[int32](queryErr, queries, "sint32", server.GetInt32)
	req.Sfixed32, queryErr = server.DecodeForm[int32](queryErr, queries, "sfixed32", server.GetInt32)
	req.OptInt32, queryErr = server.DecodeForm[*int32](queryErr, queries, "opt_int32", server.GetInt32Ptr)
	req.OptSint32, queryErr = server.DecodeForm[*int32](queryErr, queries, "opt_sint32", server.GetInt32Ptr)
	req.OptSfixed32, queryErr = server.DecodeForm[*int32](queryErr, queries, "opt_sfixed32", server.GetInt32Ptr)
	req.WrapInt32, queryErr = server.DecodeForm[*wrapperspb.Int32Value](queryErr, queries, "wrap_int32", server.GetInt32Value)
	req.ListInt32, queryErr = server.DecodeForm[[]int32](queryErr, queries, "list_int32", server.GetInt32Slice)
	req.ListSint32, queryErr = server.DecodeForm[[]int32](queryErr, queries, "list_sint32", server.GetInt32Slice)
	req.ListSfixed32, queryErr = server.DecodeForm[[]int32](queryErr, queries, "list_sfixed32", server.GetInt32Slice)
	req.ListWrapInt32, queryErr = server.DecodeForm[[]*wrapperspb.Int32Value](queryErr, queries, "list_wrap_int32", server.GetInt32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int32QueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder int32QueryGooseResponseEncoder) Int32Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Int64QueryGooseService interface {
	Int64Query(ctx context.Context, request *Int64QueryRequest) (*httpbody.HttpBody, error)
}

func AppendInt64QueryGooseRoute(router *http.ServeMux, service Int64QueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int64QueryGooseHandler{
		service: service,
		decoder: int64QueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64QueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/int64", server.Chain(handler.Int64Query(), options.Middlewares()...))
	return router
}

type int64QueryGooseHandler struct {
	service                 Int64QueryGooseService
	decoder                 int64QueryGooseRequestDecoder
	encoder                 int64QueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h int64QueryGooseHandler) Int64Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int64Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int64QueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryGooseRequestDecoder) Int64Query(ctx context.Context, r *http.Request) (*Int64QueryRequest, error) {
	req := &Int64QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Int64, queryErr = server.DecodeForm[int64](queryErr, queries, "int64", server.GetInt64)
	req.Sint64, queryErr = server.DecodeForm[int64](queryErr, queries, "sint64", server.GetInt64)
	req.Sfixed64, queryErr = server.DecodeForm[int64](queryErr, queries, "sfixed64", server.GetInt64)
	req.OptInt64, queryErr = server.DecodeForm[*int64](queryErr, queries, "opt_int64", server.GetInt64Ptr)
	req.OptSint64, queryErr = server.DecodeForm[*int64](queryErr, queries, "opt_sint64", server.GetInt64Ptr)
	req.OptSfixed64, queryErr = server.DecodeForm[*int64](queryErr, queries, "opt_sfixed64", server.GetInt64Ptr)
	req.WrapInt64, queryErr = server.DecodeForm[*wrapperspb.Int64Value](queryErr, queries, "wrap_int64", server.GetInt64Value)
	req.ListInt64, queryErr = server.DecodeForm[[]int64](queryErr, queries, "list_int64", server.GetInt64Slice)
	req.ListSint64, queryErr = server.DecodeForm[[]int64](queryErr, queries, "list_sint64", server.GetInt64Slice)
	req.ListSfixed64, queryErr = server.DecodeForm[[]int64](queryErr, queries, "list_sfixed64", server.GetInt64Slice)
	req.ListWrapInt64, queryErr = server.DecodeForm[[]*wrapperspb.Int64Value](queryErr, queries, "list_wrap_int64", server.GetInt64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int64QueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder int64QueryGooseResponseEncoder) Int64Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Uint32QueryGooseService interface {
	Uint32Query(ctx context.Context, request *Uint32QueryRequest) (*httpbody.HttpBody, error)
}

func AppendUint32QueryGooseRoute(router *http.ServeMux, service Uint32QueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint32QueryGooseHandler{
		service: service,
		decoder: uint32QueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32QueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/uint32", server.Chain(handler.Uint32Query(), options.Middlewares()...))
	return router
}

type uint32QueryGooseHandler struct {
	service                 Uint32QueryGooseService
	decoder                 uint32QueryGooseRequestDecoder
	encoder                 uint32QueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h uint32QueryGooseHandler) Uint32Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint32Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint32QueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryGooseRequestDecoder) Uint32Query(ctx context.Context, r *http.Request) (*Uint32QueryRequest, error) {
	req := &Uint32QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Uint32, queryErr = server.DecodeForm[uint32](queryErr, queries, "uint32", server.GetUint32)
	req.Fixed32, queryErr = server.DecodeForm[uint32](queryErr, queries, "fixed32", server.GetUint32)
	req.OptUint32, queryErr = server.DecodeForm[*uint32](queryErr, queries, "opt_uint32", server.GetUint32Ptr)
	req.OptFixed32, queryErr = server.DecodeForm[*uint32](queryErr, queries, "opt_fixed32", server.GetUint32Ptr)
	req.WrapUint32, queryErr = server.DecodeForm[*wrapperspb.UInt32Value](queryErr, queries, "wrap_uint32", server.GetUint32Value)
	req.ListUint32, queryErr = server.DecodeForm[[]uint32](queryErr, queries, "list_uint32", server.GetUint32Slice)
	req.ListFixed32, queryErr = server.DecodeForm[[]uint32](queryErr, queries, "list_fixed32", server.GetUint32Slice)
	req.ListWrapUint32, queryErr = server.DecodeForm[[]*wrapperspb.UInt32Value](queryErr, queries, "list_wrap_uint32", server.GetUint32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint32QueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder uint32QueryGooseResponseEncoder) Uint32Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type Uint64QueryGooseService interface {
	Uint64Query(ctx context.Context, request *Uint64QueryRequest) (*httpbody.HttpBody, error)
}

func AppendUint64QueryGooseRoute(router *http.ServeMux, service Uint64QueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint64QueryGooseHandler{
		service: service,
		decoder: uint64QueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64QueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/uint64", server.Chain(handler.Uint64Query(), options.Middlewares()...))
	return router
}

type uint64QueryGooseHandler struct {
	service                 Uint64QueryGooseService
	decoder                 uint64QueryGooseRequestDecoder
	encoder                 uint64QueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h uint64QueryGooseHandler) Uint64Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint64Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint64QueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryGooseRequestDecoder) Uint64Query(ctx context.Context, r *http.Request) (*Uint64QueryRequest, error) {
	req := &Uint64QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Uint64, queryErr = server.DecodeForm[uint64](queryErr, queries, "uint64", server.GetUint64)
	req.Fixed64, queryErr = server.DecodeForm[uint64](queryErr, queries, "fixed64", server.GetUint64)
	req.OptUint64, queryErr = server.DecodeForm[*uint64](queryErr, queries, "opt_uint64", server.GetUint64Ptr)
	req.OptFixed64, queryErr = server.DecodeForm[*uint64](queryErr, queries, "opt_fixed64", server.GetUint64Ptr)
	req.WrapUint64, queryErr = server.DecodeForm[*wrapperspb.UInt64Value](queryErr, queries, "wrap_uint64", server.GetUint64Value)
	req.ListUint64, queryErr = server.DecodeForm[[]uint64](queryErr, queries, "list_uint64", server.GetUint64Slice)
	req.ListFixed64, queryErr = server.DecodeForm[[]uint64](queryErr, queries, "list_fixed64", server.GetUint64Slice)
	req.ListWrapUint64, queryErr = server.DecodeForm[[]*wrapperspb.UInt64Value](queryErr, queries, "list_wrap_uint64", server.GetUint64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint64QueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder uint64QueryGooseResponseEncoder) Uint64Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type FloatQueryGooseService interface {
	FloatQuery(ctx context.Context, request *FloatQueryRequest) (*httpbody.HttpBody, error)
}

func AppendFloatQueryGooseRoute(router *http.ServeMux, service FloatQueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := floatQueryGooseHandler{
		service: service,
		decoder: floatQueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatQueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/float", server.Chain(handler.FloatQuery(), options.Middlewares()...))
	return router
}

type floatQueryGooseHandler struct {
	service                 FloatQueryGooseService
	decoder                 floatQueryGooseRequestDecoder
	encoder                 floatQueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h floatQueryGooseHandler) FloatQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.FloatQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.FloatQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.FloatQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type floatQueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryGooseRequestDecoder) FloatQuery(ctx context.Context, r *http.Request) (*FloatQueryRequest, error) {
	req := &FloatQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Float, queryErr = server.DecodeForm[float32](queryErr, queries, "float", server.GetFloat32)
	req.OptFloat, queryErr = server.DecodeForm[*float32](queryErr, queries, "opt_float", server.GetFloat32Ptr)
	req.WrapFloat, queryErr = server.DecodeForm[*wrapperspb.FloatValue](queryErr, queries, "wrap_float", server.GetFloat32Value)
	req.ListFloat, queryErr = server.DecodeForm[[]float32](queryErr, queries, "list_float", server.GetFloat32Slice)
	req.ListWrapFloat, queryErr = server.DecodeForm[[]*wrapperspb.FloatValue](queryErr, queries, "list_wrap_float", server.GetFloat32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type floatQueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder floatQueryGooseResponseEncoder) FloatQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type DoubleQueryGooseService interface {
	DoubleQuery(ctx context.Context, request *DoubleQueryRequest) (*httpbody.HttpBody, error)
}

func AppendDoubleQueryGooseRoute(router *http.ServeMux, service DoubleQueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := doubleQueryGooseHandler{
		service: service,
		decoder: doubleQueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doubleQueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/double", server.Chain(handler.DoubleQuery(), options.Middlewares()...))
	return router
}

type doubleQueryGooseHandler struct {
	service                 DoubleQueryGooseService
	decoder                 doubleQueryGooseRequestDecoder
	encoder                 doubleQueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h doubleQueryGooseHandler) DoubleQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.DoubleQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.DoubleQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.DoubleQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type doubleQueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryGooseRequestDecoder) DoubleQuery(ctx context.Context, r *http.Request) (*DoubleQueryRequest, error) {
	req := &DoubleQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Double, queryErr = server.DecodeForm[float64](queryErr, queries, "double", server.GetFloat64)
	req.OptDouble, queryErr = server.DecodeForm[*float64](queryErr, queries, "opt_double", server.GetFloat64Ptr)
	req.WrapDouble, queryErr = server.DecodeForm[*wrapperspb.DoubleValue](queryErr, queries, "wrap_double", server.GetFloat64Value)
	req.ListDouble, queryErr = server.DecodeForm[[]float64](queryErr, queries, "list_double", server.GetFloat64Slice)
	req.ListWrapDouble, queryErr = server.DecodeForm[[]*wrapperspb.DoubleValue](queryErr, queries, "list_wrap_double", server.GetFloat64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type doubleQueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder doubleQueryGooseResponseEncoder) DoubleQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type StringQueryGooseService interface {
	StringQuery(ctx context.Context, request *StringQueryRequest) (*httpbody.HttpBody, error)
}

func AppendStringQueryGooseRoute(router *http.ServeMux, service StringQueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := stringQueryGooseHandler{
		service: service,
		decoder: stringQueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringQueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/string", server.Chain(handler.StringQuery(), options.Middlewares()...))
	return router
}

type stringQueryGooseHandler struct {
	service                 StringQueryGooseService
	decoder                 stringQueryGooseRequestDecoder
	encoder                 stringQueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h stringQueryGooseHandler) StringQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StringQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.StringQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StringQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type stringQueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryGooseRequestDecoder) StringQuery(ctx context.Context, r *http.Request) (*StringQueryRequest, error) {
	req := &StringQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.ListString = queries["list_string"]
	req.ListWrapString = server.WrapStringSlice(queries["list_wrap_string"])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type stringQueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder stringQueryGooseResponseEncoder) StringQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

type EnumQueryGooseService interface {
	EnumQuery(ctx context.Context, request *EnumQueryRequest) (*httpbody.HttpBody, error)
}

func AppendEnumQueryGooseRoute(router *http.ServeMux, service EnumQueryGooseService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := enumQueryGooseHandler{
		service: service,
		decoder: enumQueryGooseRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumQueryGooseResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            server.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Handle("GET /v1/enum", server.Chain(handler.EnumQuery(), options.Middlewares()...))
	return router
}

type enumQueryGooseHandler struct {
	service                 EnumQueryGooseService
	decoder                 enumQueryGooseRequestDecoder
	encoder                 enumQueryGooseResponseEncoder
	errorEncoder            server.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback server.OnValidationErrCallback
}

func (h enumQueryGooseHandler) EnumQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EnumQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := server.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EnumQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EnumQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type enumQueryGooseRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryGooseRequestDecoder) EnumQuery(ctx context.Context, r *http.Request) (*EnumQueryRequest, error) {
	req := &EnumQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Status, queryErr = server.DecodeForm[EnumQueryRequest_Status](queryErr, queries, "status", server.GetInt[EnumQueryRequest_Status])
	req.OptStatus, queryErr = server.DecodeForm[*EnumQueryRequest_Status](queryErr, queries, "opt_status", server.GetIntPtr[EnumQueryRequest_Status])
	req.ListStatus, queryErr = server.DecodeForm[[]EnumQueryRequest_Status](queryErr, queries, "list_status", server.GetIntSlice[EnumQueryRequest_Status])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type enumQueryGooseResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer server.ResponseTransformer
}

func (encoder enumQueryGooseResponseEncoder) EnumQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}
